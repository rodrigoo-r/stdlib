/*
        ==== The Zelix Programming Language ====
---------------------------------------------------------
  - This file is part of the Zelix Programming Language
    codebase. Zelix is a fast, statically-typed and
    memory-safe programming language that aims to
    match native speeds while staying highly performant.
---------------------------------------------------------
  - Zelix is categorized as free software; you can
    redistribute it and/or modify it under the terms of
    the GNU General Public License as published by the
    Free Software Foundation, either version 3 of the
    License, or (at your option) any later version.
---------------------------------------------------------
  - Zelix is distributed in the hope that it will
    be useful, but WITHOUT ANY WARRANTY; without even
    the implied warranty of MERCHANTABILITY or FITNESS
    FOR A PARTICULAR PURPOSE. See the GNU General Public
    License for more details.
---------------------------------------------------------
  - You should have received a copy of the GNU General
    Public License along with Zelix. If not, see
    <https://www.gnu.org/licenses/>.
*/

package std.io;
import "@std/sys/syscall";
import "@std/buf/stdout";

/// The global stdout buffer
global __buf: std.buf.StdoutBuffer = std.buf.StdoutBuffer.new();
/// The head of the buffer
global __head: num = 0;
/// The maximum amount of characters the buffer can hold
global __max: num = __buf.max();

/// Flushes the standard output (stdout)
/// buffer, effectively writing to the
/// console.
pub fun flush() {
    if __head == 0 {
        return;
    }

    std.unsafe.sys.write(1, __head, __buf.leak());
    __head = 0;
    __buf.pos(0);
}
 
/// The Zelix Programming Language
/// built-in way to print to the 
// standard output
pub fun print(s: str) {
    // Get the length of the string
    let len: large = std.str.len(s);

    // Initial flush
    if __head + len >= __max {
        flush();
    }

    // Write the string in chunks
    while len != 0 {
        // Check if we can write the chunk as a whole
        if __head + len <= __max {
            // Write the whole string
            __buf.write(s, len);
            __head = __head + len;
            len = 0;
            break;
        }

        // Get the remaining space
        let remaining: num = __max - __head;

        // Write to the buffer
        __buf.write(s, remaining);
        __head = __head + remaining;

        // Flush the buffer
        if __head == __max {
            flush();
        }

        // Decrease the length
        len = len - remaining;
    }
}

/// The Zelix Programming Language
/// built-in way to print to the 
// standard output
pub fun println(s: str) {
    print(s);
    print("\n");
}